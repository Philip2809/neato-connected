esphome:
  [...]

  on_boot:
    - priority: 600
      then:
        - uart.write: "GetVersion \n"

api:
  [...]
  actions:
    - action: send_cmd
      variables:
        command: string
      then:
        - uart.write: !lambda |-
            // Convert to std::string
            std::string s = command;

            if (s.empty() || s.back() != '\n')
              s += "\n";

            // convert string → vector<uint8_t>
            return std::vector<uint8_t>(s.begin(), s.end());

    - action: play_sound
      variables:
        soundid: int
      then:
        - uart.write: !lambda |-
            // Create std::string
            std::string s = "PlaySound SoundId " + std::to_string(soundid) + "\n";
            // convert string → vector<uint8_t>
            return std::vector<uint8_t>(s.begin(), s.end());

logger:
  baud_rate: 0
  tx_buffer_size: 65535

uart:
  id: uart_bus
  baud_rate: 115200
  tx_pin: GPIO1
  rx_pin: GPIO13
  rx_buffer_size: 65535
  debug:
    dummy_receiver: true
    direction: RX
    after:
      bytes: 0
      #timeout: 100ms
      #delimiter: "\r\n"
      delimiter: "\x1A"
    sequence:
      - lambda: |-
          UARTDebug::log_string(direction, bytes);

          // convert bytes -> std::string
          std::string str(bytes.begin(), bytes.end());

          id(rawString).publish_state(str.c_str());

          // ---- TRIM FUNCTION ----
          auto trim = [](std::string &s) {
            // trim leading
            s.erase(s.begin(), std::find_if(s.begin(), s.end(),
                [](unsigned char ch){ return !std::isspace(ch); }));
            // trim trailing
            s.erase(std::find_if(s.rbegin(), s.rend(),
                [](unsigned char ch){ return !std::isspace(ch); }).base(), s.end());
          };

          // ---- SPLIT ON CRLF ----
          std::vector<std::string> lines;
          size_t start = 0;
          size_t end = 0;

          while ((end = str.find("\r\n", start)) != std::string::npos) {
            std::string line = str.substr(start, end - start);
            trim(line);
            if (!line.empty()) lines.push_back(line);
            start = end + 2;
          }

          if (start < str.size()) {
            std::string last = str.substr(start);
            trim(last);
            if (!last.empty()) lines.push_back(last);
          }

          if (lines.empty()) return;

          // ---- DETECT WHICH COMMAND WAS USED ----
          std::string command = lines[0];  // first line (GetErr, GetState, etc.)

          ESP_LOGI("uart_parser", "COMMAND: %s", command.c_str());

          // ---- SPECIAL PARSING FOR GetErr ----
          if (command == "GetErr") {
            // A GetErr response looks like:
            // 0: GetErr
            // 1: Error
            // 2: <error1>
            // 3: Alert
            // 4: <error2>
            // 5: USB state
            // 6: NOT connected

            id(robotError).publish_state(lines[2].c_str());
            id(robotAlert).publish_state(lines[4].c_str());
          }
          else if (command == "GetCharger") {
            // Format after the header:
            // Label,Value
            // FuelPercent,53
            // BatteryOverTemp,0
            // ...

            for (size_t i = 2; i < lines.size(); i++) {
              std::string &line = lines[i];

              size_t comma = line.find(',');
              if (comma == std::string::npos) continue;

              std::string key = line.substr(0, comma);
              std::string value = line.substr(comma + 1);

              // Trim them:
              trim(key);
              trim(value);

              ESP_LOGI("charger", "Parsed: key='%s' value='%s'",
                        key.c_str(), value.c_str());

              // ---- MATCH KEYS AND PUBLISH ----
                   if (key == "FuelPercent") id(chargerFuelPercent).publish_state(atof(value.c_str()));
              else if (key == "BatteryOverTemp") id(chargerBatteryOverTemp).publish_state(value == "1");
              else if (key == "ChargingActive") id(chargerChargingActive).publish_state(value == "1");
              else if (key == "ChargingEnabled") id(chargerChargingEnabled).publish_state(value == "1");
              else if (key == "ConfidentOnFuel") id(chargerConfidentOnFuel).publish_state(value == "1");
              else if (key == "OnReservedFuel") id(chargerOnReservedFuel).publish_state(value == "1");
              else if (key == "EmptyFuel") id(chargerEmptyFuel).publish_state(value == "1");
              else if (key == "BatteryFailure") id(chargerBatteryFailure).publish_state(value == "1");
              else if (key == "ExtPwrPresent") id(chargerExtPwrPresent).publish_state(value == "1");
              else if (key == "ThermistorPresent") id(chargerThermistorPresent).publish_state(value == "1");
              else if (key == "BattTempCAvg") id(chargerBattTempCAvg).publish_state(atof(value.c_str()));
              else if (key == "VBattV") id(chargerVBattV).publish_state(atof(value.c_str()));
              else if (key == "VExtV") id(chargerVExtV).publish_state(atof(value.c_str()));
              else if (key == "Charger_mAH") id(chargerCharger_mAH).publish_state(atof(value.c_str()));
              else if (key == "Discharge_mAH") id(chargerDischarge_mAH).publish_state(atof(value.c_str()));
            }
          }
          else if (command == "GetVersion") {
            for (auto &line : lines) {
              size_t comma = line.find(',');
              if (comma == std::string::npos) continue;

              std::string key = line.substr(0, comma);
              std::string value = line.substr(comma + 1);
              trim(key);
              trim(value);

                   if (key == "MainBoard Serial Number") id(mainBoardSerial).publish_state(value.c_str());
              else if (key == "MainBoard Version") id(mainBoardVersion).publish_state(value.c_str());
              else if (key == "Serial Number") id(robotSerial).publish_state(value.c_str());
              else if (key == "Model") id(robotModel).publish_state(value.c_str());
              else if (key == "Time Local") id(timeLocal).publish_state(value.c_str());
              else if (key == "Time UTC") id(timeUTC).publish_state(value.c_str());
            }
          } else if (command == "TestMode") {
            for (auto &line : lines) {
              trim(line);  // optional: remove extra spaces
              if (line.find("TestMode: On") != std::string::npos) {
                id(testMode).publish_state(true);
              } else if (line.find("TestMode: Off") != std::string::npos) {
                id(testMode).publish_state(false);
              }
            }
          } else if (command == "GetState") {
            for (auto &line : lines) {
              trim(line);  // remove whitespace

              const std::string prefix = "Current State is: ";
              if (line.find(prefix) == 0) {
                std::string state = line.substr(prefix.length());
                trim(state);  // remove trailing spaces/newlines
                id(currentState).publish_state(state.c_str());
              }
            }
          }

          // ---- OPTIONAL: print each line for debugging ----
          //for (auto &line : lines) {
            //std::vector<uint8_t> v(line.begin(), line.end());
            //UARTDebug::log_string(direction, v);
            //ESP_LOGI("uart_parser", "LINE: %s", line.c_str());
          //}



sensor:
  # --- GetCharger ---
  - platform: template
    id: chargerFuelPercent
    name: "Fuel Percent"
    unit_of_measurement: "%"

  - platform: template
    id: chargerBattTempCAvg
    name: "Battery Temp C Avg"
    unit_of_measurement: "°C"
    entity_category: "diagnostic"

  - platform: template
    id: chargerVBattV
    name: "Battery Voltage V"
    unit_of_measurement: "V"
    entity_category: "diagnostic"

  - platform: template
    id: chargerVExtV
    name: "External Voltage V"
    unit_of_measurement: "V"
    entity_category: "diagnostic"

  - platform: template
    id: chargerCharger_mAH
    name: "Charger mAh"
    unit_of_measurement: "mAh"
    entity_category: "diagnostic"

  - platform: template
    id: chargerDischarge_mAH
    name: "Discharge mAh"
    unit_of_measurement: "mAh"
    entity_category: "diagnostic"

binary_sensor:
  # --- GetCharger ---
  - platform: template
    id: chargerBatteryOverTemp
    name: "Battery Over Temp"
    entity_category: "diagnostic"

  - platform: template
    id: chargerChargingActive
    name: "Charging Active"
    entity_category: "diagnostic"

  - platform: template
    id: chargerChargingEnabled
    name: "Charging Enabled"
    entity_category: "diagnostic"

  - platform: template
    id: chargerConfidentOnFuel
    name: "Confident On Fuel"
    entity_category: "diagnostic"

  - platform: template
    id: chargerOnReservedFuel
    name: "On Reserved Fuel"
    entity_category: "diagnostic"

  - platform: template
    id: chargerEmptyFuel
    name: "Empty Fuel"
    entity_category: "diagnostic"

  - platform: template
    id: chargerBatteryFailure
    name: "Battery Failure"
    entity_category: "diagnostic"

  - platform: template
    id: chargerExtPwrPresent
    name: "Ext Power Present"
    entity_category: "diagnostic"

  - platform: template
    id: chargerThermistorPresent
    name: "Thermistor Present"
    entity_category: "diagnostic"


text_sensor:
  - platform: template
    id: rawString
    name: "UART msg"

  - platform: template
    id: robotError
    name: "Robot Error"

  - platform: template
    id: robotAlert
    name: "Robot Alert"

  # --- GetVersion ---
  - platform: template
    id: mainBoardSerial
    name: "MainBoard Serial Number"
    entity_category: "diagnostic"

  - platform: template
    id: mainBoardVersion
    name: "MainBoard Version"
    entity_category: "diagnostic"

  - platform: template
    id: robotSerial
    name: "Serial Number"
    entity_category: "diagnostic"

  - platform: template
    id: robotModel
    name: "Model"
    entity_category: "diagnostic"

  - platform: template
    id: timeLocal
    name: "Time Local"
    entity_category: "diagnostic"

  - platform: template
    id: timeUTC
    name: "Time UTC"
    entity_category: "diagnostic"

  # --- GetState ---
  - platform: template
    name: "Current State"
    id: currentState


switch:
  - platform: template
    name: "Test Mode"
    id: testMode
    turn_on_action:
      - uart.write: "TestMode On \n"
    turn_off_action:
      - uart.write: "TestMode Off \n"


button:
  - platform: template
    name: "House Clean"
    on_press:
      - uart.write: "Clean \n"

  - platform: template
    name: "Spot Clean"
    on_press:
      - uart.write: "Clean Spot \n"

  - platform: template
    name: "STOP"
    on_press:
      - uart.write: "Clean Stop \n"

  - platform: template
    name: "Test Button 4 (GetState)"
    on_press:
      - uart.write: "GetState \n" 

  - platform: template
    name: "Get usersettings"
    on_press:
      - uart.write: "GetUserSettings \n"  

  - platform: template
    name: "gettime"
    on_press:
      - uart.write: "GetTime \n"  

  - platform: template
    name: "Locate Robot"
    on_press:
      - uart.write: "PlaySound SoundId 20 \n"  

  - platform: template
    name: "GetUsage"
    on_press:
      - uart.write: "GetUsage \n"    

#if you need to send a request periodically to get response from the uart device 
interval:
  - interval: 2sec
    then:
      - uart.write: "GetErr \n"
      - uart.write: "GetState \n"
  - interval: 2min
    then: 
      - uart.write: "GetCharger \n"
  - interval: 30min
    then: 
      - uart.write: "TestMode \n"
